/* 
 * Eterra Framework
 * A simple framework for creating multimedia applications.
 * Copyright (C) 2020, Maximilian Bauer (contact@lengo.cc)
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

using System;
using System.Globalization;
using System.IO;
using System.Runtime.InteropServices;

namespace Eterra.Common
{
    /// <summary>
    /// Represents a (triangular) polygon, which is defined through vertices 
    /// stored in a parent mesh structure and referenced by indicies.
    /// The order of the indicies should be clockwise.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public readonly struct Face
    {
        /// <summary>
        /// Defines the character which is used to separate the components
        /// in the string representation of instances of this struct.
        /// </summary>
        public const char ComponentSeparator = ';';

        /// <summary>
        /// Defines the amount of components the string representation of
        /// the vertex must have to be valid.
        /// </summary>
        private const int ComponentCount = 3;

        /// <summary>
        /// Gets the size of a <see cref="Face"/> instance in bytes.
        /// </summary>
        public static int Size { get; } = Marshal.SizeOf(typeof(Face));

        /// <summary>
        /// Gets the first vertex index.
        /// </summary>
        public uint FirstVertexIndex { get; }

        /// <summary>
        /// Gets the second vertex index.
        /// </summary>
        public uint SecondVertexIndex { get; }

        /// <summary>
        /// Gets the third vertex index.
        /// </summary>
        public uint ThirdVertexIndex { get; }

        /// <summary>
        /// Creates a new face.
        /// </summary>
        /// <param name="firstVertexIndex">
        /// The index of the first vertex.
        /// </param>
        /// <param name="secondVertexIndex">
        /// The index of the second vertex.
        /// </param>
        /// <param name="thirdVertexIndex">
        /// The index of the third vertex.
        /// </param>
        public Face(uint firstVertexIndex, uint secondVertexIndex,
            uint thirdVertexIndex)
        {
            FirstVertexIndex = firstVertexIndex;
            SecondVertexIndex = secondVertexIndex;
            ThirdVertexIndex = thirdVertexIndex;
        }

        /// <summary>
        /// Creates a new <see cref="Face"/> for a different coordinate system
        /// (between left-handed and right-handed) by interconverting the 
        /// <see cref="SecondVertexIndex"/> and the 
        /// <see cref="ThirdVertexIndex"/>.
        /// </summary>
        /// <returns>A new <see cref="Face"/> instance.</returns>
        public Face Flipped()
        {
            return new Face(FirstVertexIndex, ThirdVertexIndex, 
                SecondVertexIndex);
        }

        /// <summary>
        /// Generates a face string, which consists of the three vertex 
        /// indicies separated by the character defined in 
        /// <see cref="ComponentSeparator"/>. The invariant culture is used
        /// to convert the numbers to strings.
        /// </summary>
        /// <returns>A new string.</returns>
        public override string ToString()
        {
            CultureInfo c = CultureInfo.InvariantCulture;

            using (StringWriter vw = new StringWriter())
            {
                vw.Write(FirstVertexIndex.ToString(c));
                vw.Write(ComponentSeparator);
                vw.Write(SecondVertexIndex.ToString(c));
                vw.Write(ComponentSeparator);
                vw.Write(ThirdVertexIndex.ToString(c));
                return vw.ToString();
            }
        }

        /// <summary>
        /// Parses a face from a string in the format generated by
        /// <see cref="ToString"/>. The invariant culture is used for
        /// parsing the contained numbers.
        /// </summary>
        /// <param name="str">The face string.</param>
        /// <returns>A new face.</returns>
        /// <exception cref="ArgumentNullException">
        /// Is thrown when <paramref name="str"/> is null.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// Is thrown when <paramref name="str"/> has an invalid format.
        /// </exception>
        public static Face Parse(string str)
        {
            if (str == null) throw new ArgumentNullException(nameof(str));

            CultureInfo c = CultureInfo.InvariantCulture;

            string[] elements = str.Split(ComponentSeparator);
            if (elements.Length != ComponentCount)
                throw new ArgumentException("The specified string had an " +
                    "invalid amount of components!");
            else
            {
                try
                {
                    return new Face(uint.Parse(elements[0], c),
                        uint.Parse(elements[1], c), 
                        uint.Parse(elements[2], c));
                }
                catch
                {
                    throw new ArgumentException("The specified string had " +
                        "invalid component values!");
                }
            }
        }
    }
}
