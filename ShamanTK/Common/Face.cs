/* 
 * ShamanTK
 * A toolkit for creating multimedia applications.
 * Copyright (C) 2020, Maximilian Bauer (contact@lengo.cc)
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Runtime.InteropServices;
using System.Text.RegularExpressions;

namespace ShamanTK.Common
{
    /// <summary>
    /// Represents a (triangular) polygon, which is defined through vertices 
    /// stored in a parent mesh structure and referenced by indicies.
    /// The order of the indicies should be clockwise.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public readonly struct Face
    {
        /// <summary>
        /// Gets the size of a <see cref="Face"/> instance in bytes.
        /// </summary>
        public static int Size { get; } = Marshal.SizeOf(typeof(Face));

        /// <summary>
        /// Gets the first vertex index.
        /// </summary>
        public uint FirstVertexIndex { get; }

        /// <summary>
        /// Gets the second vertex index.
        /// </summary>
        public uint SecondVertexIndex { get; }

        /// <summary>
        /// Gets the third vertex index.
        /// </summary>
        public uint ThirdVertexIndex { get; }

        /// <summary>
        /// Creates a new face.
        /// </summary>
        /// <param name="firstVertexIndex">
        /// The index of the first vertex.
        /// </param>
        /// <param name="secondVertexIndex">
        /// The index of the second vertex.
        /// </param>
        /// <param name="thirdVertexIndex">
        /// The index of the third vertex.
        /// </param>
        public Face(uint firstVertexIndex, uint secondVertexIndex,
            uint thirdVertexIndex)
        {
            FirstVertexIndex = firstVertexIndex;
            SecondVertexIndex = secondVertexIndex;
            ThirdVertexIndex = thirdVertexIndex;
        }

        /// <summary>
        /// Creates a new <see cref="Face"/> for a different coordinate system
        /// (between left-handed and right-handed) by interconverting the 
        /// <see cref="SecondVertexIndex"/> and the 
        /// <see cref="ThirdVertexIndex"/>.
        /// </summary>
        /// <returns>A new <see cref="Face"/> instance.</returns>
        public Face Flipped()
        {
            return new Face(FirstVertexIndex, ThirdVertexIndex, 
                SecondVertexIndex);
        }

        /// <summary>
        /// Converts the current <see cref="Face"/> instance to a string 
        /// representation with each vertex index in ascending order, seperated
        /// by a single whitespace.
        /// </summary>
        /// <returns>A new <see cref="string"/>.</returns>
        public override string ToString()
        {
            CultureInfo c = CultureInfo.InvariantCulture;

            using (StringWriter vw = new StringWriter())
            {
                vw.Write(FirstVertexIndex.ToString(c)); vw.Write(' ');
                vw.Write(SecondVertexIndex.ToString(c)); vw.Write(' ');
                vw.Write(ThirdVertexIndex.ToString(c));

                return vw.ToString();
            }
        }

        /// <summary>
        /// Parses a <see cref="string"/> into a collection of 
        /// <see cref="Face"/> instances, expecting the faces to be in the
        /// format as it's generated by <see cref="ToString"/>.
        /// </summary>
        /// <param name="facesString">
        /// The string representation of a collection of faces.
        /// </param>
        /// <returns>A new array of <see cref="Face"/> instances.</returns>
        /// <exception cref="ArgumentNullException">
        /// Is thrown when <paramref name="facesString"/> is null.
        /// </exception>
        /// <exception cref="FormatException">
        /// Is thrown when the specified <paramref name="facesString"/> is
        /// invalid.
        /// </exception>
        public static Face[] Parse(string facesString)
        {
            List<Face> faces = new List<Face>();

            uint[] vertexIndicies = new uint[3];
            int currentVertexIndexPosition = 0;

            Regex segmentCapture = new Regex("[.\\S]+");
            Match match = segmentCapture.Match(facesString);
            while (match.Success)
            {
                int parserIndex = match.Index;

                if (uint.TryParse(match.Value, out uint vertexIndex))
                    vertexIndicies[currentVertexIndexPosition] = vertexIndex;
                else throw new FormatException("Invalid face vertex index " +
                    "value (" + currentVertexIndexPosition +
                    ") at " + parserIndex + ".");

                if (++currentVertexIndexPosition >= vertexIndicies.Length)
                {
                    faces.Add(new Face(vertexIndicies[0], vertexIndicies[1],
                        vertexIndicies[2]));
                    currentVertexIndexPosition = 0;

                    vertexIndicies[0] = vertexIndicies[1] = 
                        vertexIndicies[2] = 0;
                }

                match = match.NextMatch();
            }

            if (currentVertexIndexPosition != 0)
                throw new FormatException("Last face definition incomplete.");
            else return faces.ToArray();
        }
    }
}
